C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5C51\C51\BIN\C51.EXE main.c ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "SN8F5702.H"
   2          #include "intrins.h"
   3          #include "delayms.h"
   4          #include "433send.h"
   5          #include "getkey.h"
   6          #include "ISP.h"
   7          #include "gpio.h"
   8          #include "tmr.h"
   9          
  10          #define uint8_t unsigned char
  11          #define uinttrue6_t unsigned int
  12          
  13          #define true 1
  14          #define false 0
  15          
  16          #define KEY_NULL 0x00
  17          #define KEY_CH1 0x01
  18          #define KEY_CH2 0x02
  19          #define KEY_CH3 0x03
  20          #define KEY_CH4 0x04
  21          
  22          #define KEY_TEMP_UP 0x05
  23          #define KEY_TEMP_DOWN 0x06
  24          
  25          #define KEY_AIR_UP 0x07
  26          #define KEY_AIR_DOWN 0x08
  27          #define KEY_SWITCH_HANDLE 0x09
  28          
  29          #define KEY_Right_Code 0xff
  30          #define KEY_CLEAR_CODE 0x0f
  31          
  32          sbit SEND_LED = P2 ^ 4;
  33          sbit Battery_LED = P2 ^ 3;
  34          sbit charge_flag = P2 ^ 1; 
  35          
  36          volatile uint8_t key_out_time = 0, key_state = 0,key_n = 0,start_init_outtime = 0,reset_led_time = 0;
  37          volatile uint8_t send_data = 0,first_get_addr_complete_flag = 0,send_counter = 0,led_times = 0,while_n = 0
             -x00;
  38          volatile uint16_t send_addr = 0;
  39          volatile bit key_ent_flag = 0,longkey_flag = 0,tmr_stop_flag = 0,start_init_flag = 0,reset_flag = 0;
  40          volatile bit start_init_end_flag = 0,key_stop_tmr_flag = 0,send_finish_flag = 0,open_led_flag = 0;
  41          
  42          void key_handle(void);
  43          void fisrt_get_addr_handle(void);
  44          void send_handle(void);
  45          void Start_init_handle(void);
  46          void Rom_write(uinttrue6_t in_data, uint8_t n);
  47          void Rom_read(void);
  48          uint16_t data_8bit_to_16bit(uint8_t n);
  49          void check_key(void);
  50          
  51          void T0Interrupt(void) interrupt ISRTimer0  
  52          {
  53   1              //TF0 clear
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 2   

  54   1              TF0 = 0;
  55   1              TH0 = 0;
  56   1              TL0 = 0;
  57   1      }
  58          
  59          
  60          void T1Interrupt(void) interrupt ISRTimer1
  61          {
  62   1              if(key_n != 0x00)
  63   1              {
  64   2                      key_n --;
  65   2              }
  66   1              if(start_init_outtime != 0x00)
  67   1              {
  68   2                      start_init_outtime--;
  69   2              }
  70   1              if(key_out_time != 0x00)
  71   1              {
  72   2                      key_out_time--;
  73   2              }
  74   1      
  75   1              if(reset_flag == true)
  76   1              {
  77   2                      if(reset_led_time != 0x00)
  78   2                      {
  79   3                              reset_led_time--;
  80   3                      }
  81   2                      else
  82   2                      {
  83   3                              reset_led_time = 0x01;
  84   3                              SEND_LED = ~SEND_LED;
  85   3                      }
  86   2              }
  87   1              TH1 = (65536 - 10000) / 256;
  88   1              TL1 = (65536 - 10000) % 256;
  89   1              ET1 = 1; 
  90   1              TR1 = 1; 
  91   1              TF1 = 0;
  92   1      }
  93          
  94          void main(void)
  95          {
  96   1              /* system clock */
  97   1              CKCON = 0x70;
  98   1              CLKSEL = 0x05; // Fcpu = 32M
  99   1              CLKCMD = 0x69;
 100   1              WDTR = 0x5A;
 101   1      
 102   1              gpio_init();
 103   1              InitT0(); // 用于获取滚动码
 104   1              InitT1();
 105   1              Witty433_Init(set_433time_buf); // 433发送电平时间设置
 106   1              Rom_read();
 107   1              while (1)
 108   1              {
 109   2                      WDTR = 0x5A;
 110   2                      if (start_init_flag == 0)
 111   2                      {
 112   3                              if (first_get_addr_complete_flag == false)
 113   3                              {
 114   4                                      if(key_stop_tmr_flag == true)
 115   4                                      {
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 3   

 116   5                                              // 出厂首次获取滚动码
 117   5                                              first_get_addr_complete_flag = true; // 设置首次获取地址码完成标志位
 118   5                                              key_stop_tmr_flag = false;                      
 119   5                                              start_init_flag = true;                         // 设置开始标志位
 120   5                                              fisrt_get_addr_handle();        
 121   5                                      }
 122   4                                      else
 123   4                                      {
 124   5      //                                      StartSend_433(0xffff, 0x00);
 125   5                                      }
 126   4                                                                                                                      // 获取地址码   
 127   4                              }
 128   3                              else 
 129   3                              {
 130   4                                      send_data = key_state;
 131   4                                      send_handle(); // 433发送处理
 132   4                              }
 133   3                      }
 134   2                      else 
 135   2                              Start_init_handle(); // 初始化处理
 136   2                      switch(while_n)
 137   2                      {
 138   3                              case 1: 
 139   3                                      if(reset_flag == false)
 140   3                                      {
 141   4                                              if(open_led_flag == true)
 142   4                                              {
 143   5                                                      SEND_LED = true;
 144   5                                                      led_times++;
 145   5                                                      if(led_times > 10)
 146   5                                                      {
 147   6                                                              SEND_LED = false;
 148   6                                                              led_times = 0;
 149   6                                                      }
 150   5                                              }
 151   4                                      }
 152   3                                      if(charge_flag == 0)
 153   3                                              Battery_LED = true;
 154   3                                      else 
 155   3                                              Battery_LED = false;
 156   3                                      break;
 157   3                              case 2:
 158   3                                      if (key_n  == 0)
 159   3                                      {
 160   4                                              key_handle(); // 按键识别
 161   4                                              key_n  = 0x02;
 162   4                                      }
 163   3                                      break;
 164   3                              default:
 165   3                                      while_n = 0x00;
 166   3                                      break;
 167   3                              
 168   3                      }
 169   2                      while_n++;
 170   2                      
 171   2              }
 172   1      }
 173          
 174          /*
 175           * 433发送处理
 176           * 起始码+地址码+控制码+结束码
 177           */
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 4   

 178          void send_handle(void)
 179          {
 180   1      #if 1
 181   1              //发送5帧数据
 182   1              if(longkey_flag == true)  //长按一直发送
 183   1              {
 184   2                      StartSend_433(send_addr, send_data);
 185   2                      send_finish_flag = true;
 186   2                      open_led_flag = true;
 187   2              }
 188   1              else
 189   1              {
 190   2                      if(send_finish_flag == false)
 191   2                      {
 192   3                              StartSend_433(send_addr, send_data);
 193   3                              send_finish_flag = true;
 194   3      //                      send_counter++;
 195   3      //                      if(send_counter > 1)
 196   3      //                      {
 197   3      //                              key_state = KEY_NULL;
 198   3      //                              send_finish_flag = true;
 199   3      //                              send_counter = 0x00;
 200   3      //                              open_led_flag = true;
 201   3      //                      }
 202   3                      }
 203   2                      
 204   2              }
 205   1              
 206   1      
 207   1      
 208   1              
 209   1      #endif
 210   1      
 211   1      }
 212          
 213          /*
 214           *出厂首次获取地址码
 215           *通过定时器计数获取计数时间
 216           *计数时间作为地址码存储到flash中
 217           *计数时间范围0~65535
 218           *计数暂停标志为确认键长按
 219           */
 220          void fisrt_get_addr_handle(void)
 221          {                                 
 222   1              StopT0();                                                                                                                                 // 停止计数
 223   1              send_addr = TH0  << 8 | TL0;                              // 获取计数时间作为地址码
 224   1              u8_data[2] = first_get_addr_complete_flag; // 地址码高位
 225   1              Rom_write(send_addr, 0);                                          // 写入Flash
 226   1      }
 227          void Start_init_handle(void)
 228          {
 229   1              if (start_init_flag == true && start_init_end_flag == 0)
 230   1              {
 231   2      
 232   2                      start_init_end_flag = true; // 设置结束标志位
 233   2                      start_init_outtime = 0x0A;
 234   2                      send_finish_flag = false;
 235   2                      /* 读取ROM数据 */
 236   2                      send_addr = data_8bit_to_16bit(0); // ROM地址
 237   2      
 238   2                      first_get_addr_complete_flag = u8_data[2]; // 首次获取地址码完成标志位
 239   2                      if(first_get_addr_complete_flag > 1)
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 5   

 240   2                              first_get_addr_complete_flag = 0;
 241   2                      if (first_get_addr_complete_flag == false)
 242   2                      {
 243   3                              // 出厂定时器开始计数
 244   3                              TH0 = 0x00; // 计数器清零
 245   3                              TL0 = 0x00;
 246   3                              StartT0(); // 启动计数
 247   3                      }
 248   2                      else
 249   2                              StopT0(); // 停止计数
 250   2              }
 251   1              else if (start_init_end_flag == true && start_init_outtime == 0x00)
 252   1              {
 253   2                      start_init_flag = false; // 复位标志位
 254   2                      start_init_end_flag = false;
 255   2              }
 256   1      }
 257          
 258          void Rom_write(uinttrue6_t in_data, uint8_t n)
 259          {
 260   1              /* true6bit数据暂存数组 */
 261   1              u8_data[n] = in_data >> 8; // 高位
 262   1              u8_data[n + 1] = in_data;  // 低位
 263   1              ISPpagewrite(u8_data);
 264   1      }
 265          
 266          uint16_t data_8bit_to_16bit(uint8_t n)
 267          {
 268   1              uinttrue6_t out_data;
 269   1              out_data = (u8_data[n] << 8) | u8_data[n + 1]; // true6bit数据
 270   1              return out_data;
 271   1      }
 272          void Rom_read(void)
 273          {
 274   1              ISPpageread2();
 275   1              start_init_flag = true;
 276   1              start_init_end_flag = 0;
 277   1              start_init_outtime = 0x00;
 278   1      }
 279          
 280          
 281          #if 1
 282          void key_handle(void)
 283          {
 284   1              uint8_t key_value;
 285   1              key_value = get_key();
 286   1              if (inkey_number == key_temp_up)
 287   1              {
 288   2                      switch (key_value)
 289   2                      {
 290   3                      case (keydown_ent):
 291   3                              break;
 292   3                      case (keyup_ent):
 293   3                      {
 294   4                              if(longkey_flag == 0)
 295   4                              {
 296   5                                      key_ent_flag = true;
 297   5                                      key_state = KEY_TEMP_UP;
 298   5                                      send_finish_flag = false;
 299   5                              }
 300   4                              inkey_number = key_null;
 301   4                              longkey_flag = false;
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 6   

 302   4                              key_out_time = 0x05;
 303   4                      }
 304   3                      break;
 305   3                      case (key_long):
 306   3                              break;
 307   3                      case (key_continue):
 308   3                      {
 309   4                              if(longkey_flag == 0)
 310   4                              {
 311   5                                      key_ent_flag = true;
 312   5                                      key_state = KEY_TEMP_UP;
 313   5                                      send_finish_flag = false;
 314   5                                      longkey_flag = true;
 315   5                                      key_out_time = 0x05;
 316   5                              }
 317   4                      }
 318   3                      break;
 319   3                      default:
 320   3                              break;
 321   3                      }
 322   2              }
 323   1              else if (inkey_number == key_temp_down)
 324   1              {
 325   2                      switch (key_value)
 326   2                      {
 327   3                      case (keydown_ent):
 328   3                              break;
 329   3                      case (keyup_ent):
 330   3                      {
 331   4                              if(longkey_flag == 0)
 332   4                              {
 333   5                                      key_ent_flag = true;
 334   5                                      key_state = KEY_TEMP_DOWN;
 335   5                                      send_finish_flag = false;
 336   5                              }
 337   4                              longkey_flag = false;
 338   4                              inkey_number = key_null;
 339   4                              key_out_time = 0x05;
 340   4                      }
 341   3                      break;
 342   3                      case (key_long):
 343   3                              break;
 344   3                      case (key_continue):
 345   3                      {
 346   4                              if(longkey_flag == 0)
 347   4                              {
 348   5                                      key_ent_flag = true;
 349   5                                      key_state = KEY_TEMP_DOWN;
 350   5                                      send_finish_flag = false;
 351   5                                      longkey_flag = true;
 352   5                                      key_out_time = 0x05;
 353   5                              }
 354   4                      }
 355   3                      break;
 356   3                      default:
 357   3                              break;
 358   3                      }
 359   2              }
 360   1              else if (inkey_number == key_air_up)
 361   1              {
 362   2                      switch (key_value)
 363   2                      {
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 7   

 364   3                      case (keydown_ent):
 365   3                              break;
 366   3                      case (keyup_ent):
 367   3                      {
 368   4                              if(longkey_flag == 0)
 369   4                              {
 370   5                                      key_ent_flag = true;
 371   5                                      key_state = KEY_AIR_UP;
 372   5                                      send_finish_flag = false;
 373   5                              }
 374   4                              longkey_flag = false;
 375   4                              inkey_number = key_null;
 376   4                              key_out_time = 0x05;
 377   4                      }
 378   3                      break;
 379   3                      case (key_long):
 380   3                              break;
 381   3                      case (key_continue):
 382   3                      {
 383   4                              if(longkey_flag == 0)
 384   4                              {
 385   5                                      key_ent_flag = true;
 386   5                                      key_state = KEY_AIR_UP;
 387   5                                      send_finish_flag = false;
 388   5                                      longkey_flag = true;
 389   5                                      key_out_time = 0x05;
 390   5                              }
 391   4                      }
 392   3                      break;
 393   3                      default:
 394   3                              break;
 395   3                      }
 396   2              }
 397   1              else if (inkey_number == key_air_down)
 398   1              {
 399   2                      switch (key_value)
 400   2                      {
 401   3                      case (keydown_ent):
 402   3                              break;
 403   3                      case (keyup_ent):
 404   3                      {
 405   4                              if(longkey_flag == 0)
 406   4                              {
 407   5                              key_ent_flag = true;
 408   5                              key_state = KEY_AIR_DOWN;
 409   5                              send_finish_flag = false;
 410   5                              }
 411   4                              longkey_flag = false;
 412   4                              inkey_number = key_null;
 413   4                              key_out_time = 0x05;
 414   4                      }
 415   3                      break;
 416   3                      case (key_long):
 417   3                              break;
 418   3                      case (key_continue):
 419   3                      {
 420   4                              if(longkey_flag == 0)
 421   4                              {
 422   5                                      key_ent_flag = true;
 423   5                                      key_state = KEY_AIR_DOWN;
 424   5                                      send_finish_flag = false;
 425   5                                      longkey_flag = true;
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 8   

 426   5                                      key_out_time = 0x05;
 427   5                              }
 428   4                      }
 429   3                      break;
 430   3                      default:
 431   3                              break;
 432   3                      }
 433   2              }
 434   1              else if (inkey_number == key_ch1)
 435   1              {
 436   2                      switch (key_value)
 437   2                      {
 438   3                      case (keydown_ent):
 439   3                              break;
 440   3                      case (keyup_ent):
 441   3                      {
 442   4                              key_ent_flag = true;
 443   4                              key_state = KEY_CH1;
 444   4                              send_finish_flag = false;
 445   4                              inkey_number = key_null;
 446   4                              key_out_time = 0x05;
 447   4                      }
 448   3                      break;
 449   3                      case (key_long):
 450   3                              break;
 451   3                      case (key_continue):
 452   3                      {
 453   4                              key_ent_flag = true;
 454   4                              longkey_flag = true;
 455   4                      }
 456   3                      break;
 457   3                      default:
 458   3                              break;
 459   3                      }
 460   2              }
 461   1              else if (inkey_number == key_ch2)
 462   1              {
 463   2                      switch (key_value)
 464   2                      {
 465   3                      case (keydown_ent):
 466   3                              break;
 467   3                      case (keyup_ent):
 468   3                      {
 469   4                              key_ent_flag = true;
 470   4                              key_state = KEY_CH2;
 471   4                              send_finish_flag = false;
 472   4                              inkey_number = key_null;
 473   4                              key_out_time = 0x05;
 474   4                      }
 475   3                      break;
 476   3                      case (key_long):
 477   3                              break;
 478   3                      case (key_continue):
 479   3                      {
 480   4                              key_ent_flag = true;
 481   4                              longkey_flag = true;
 482   4                      }
 483   3                      break;
 484   3                      default:
 485   3                              break;
 486   3                      }
 487   2              }
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 9   

 488   1              else if (inkey_number == key_ch3)
 489   1              {
 490   2                      switch (key_value)
 491   2                      {
 492   3                      case (keydown_ent):
 493   3                              break;
 494   3                      case (keyup_ent):
 495   3                      {
 496   4                              key_ent_flag = true;
 497   4                              key_state = KEY_CH3;
 498   4                              send_finish_flag = false;
 499   4                              inkey_number = key_null;
 500   4                              key_out_time = 0x05;
 501   4                      }
 502   3                      break;
 503   3                      case (key_long):
 504   3                              break;
 505   3                      case (key_continue):
 506   3                      {
 507   4                              key_ent_flag = true;
 508   4                              longkey_flag = true;
 509   4                      }
 510   3                      break;
 511   3                      default:
 512   3                              break;
 513   3                      }
 514   2              }
 515   1              else if (inkey_number == key_ch4)
 516   1              {
 517   2                      switch (key_value)
 518   2                      {
 519   3                      case (keydown_ent):
 520   3                              break;
 521   3                      case (keyup_ent):
 522   3                      {
 523   4                              key_ent_flag = true;
 524   4                              key_state = KEY_CH4;
 525   4                              send_finish_flag = false;
 526   4                              inkey_number = key_null;
 527   4                              key_out_time = 0x05;
 528   4                      }
 529   3                      break;
 530   3                      case (key_long):
 531   3                              break;
 532   3                      case (key_continue):
 533   3                      {
 534   4                              key_ent_flag = true;
 535   4                              longkey_flag = true;
 536   4                      }
 537   3                      break;
 538   3                      default:
 539   3                              break;
 540   3                      }
 541   2              }
 542   1              else if (inkey_number == KEY_Switch_handle)
 543   1              {
 544   2                      /* 确认按键  &  滚动码
 545   2                       * 滚动码 ： 长按确认键 确定机器滚动码
 546   2                       */
 547   2                      switch (key_value)
 548   2                      {
 549   3                      case (keyup_ent):
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 10  

 550   3                      {
 551   4                              if(longkey_flag == 0)
 552   4                              {
 553   5                                      //切换手柄
 554   5                                      key_ent_flag = true;
 555   5                                      key_state = KEY_SWITCH_HANDLE;
 556   5                                      send_finish_flag = false;
 557   5                                      key_out_time = 0x05;
 558   5                              }
 559   4                              longkey_flag = false;
 560   4                              inkey_number = key_null;
 561   4                      }
 562   3                      break;
 563   3                      case (key_continue):
 564   3                      {
 565   4                              if(longkey_flag == 0)
 566   4                              {
 567   5                                      key_ent_flag = true;
 568   5                                      if(first_get_addr_complete_flag == false)
 569   5                                              key_stop_tmr_flag = true; // 停止计数
 570   5                                      else
 571   5                                              key_state = KEY_Right_Code;
 572   5                                      send_finish_flag = false;
 573   5                                      longkey_flag = true;
 574   5                                      key_out_time = 0x05;
 575   5                              }
 576   4                              
 577   4                      }
 578   3                      break;
 579   3                      default:
 580   3                              break;
 581   3                      }
 582   2              }
 583   1              else if (inkey_number == key_clear)
 584   1              {
 585   2                      /* 清除对码  
 586   2                       */
 587   2                      switch (key_value)
 588   2                      {
 589   3                      case (keyup_ent):
 590   3                      {
 591   4                              inkey_number = key_null;
 592   4                              longkey_flag = false;
 593   4                      }
 594   3                      break;
 595   3                      case (key_continue):
 596   3                      {
 597   4                              if(longkey_flag == 0)
 598   4                              {
 599   5                                      key_ent_flag = true;
 600   5                                      key_state = KEY_CLEAR_CODE;
 601   5                                      send_finish_flag = false;
 602   5                                      longkey_flag = true;
 603   5                                      key_out_time = 0x05;
 604   5                              }
 605   4                              
 606   4                      }
 607   3                      break;
 608   3                      default:
 609   3                              break;
 610   3                      }
 611   2              }
C51 COMPILER V9.60.7.0   MAIN                                                              09/06/2025 13:36:19 PAGE 11  

 612   1              else if( inkey_number == key_reset)
 613   1              {
 614   2                      /* 恢复出厂设置 需要重新获取滚动码  
 615   2                       */
 616   2                      switch (key_value)
 617   2                      {
 618   3                      case (keyup_ent):
 619   3                      {
 620   4                              inkey_number = key_null;
 621   4                              longkey_flag = false;
 622   4                      }
 623   3                      break;
 624   3                      case (key_continue):
 625   3                      {
 626   4                              if(longkey_flag == 0)
 627   4                              {
 628   5                                      key_ent_flag = true;
 629   5                                      send_addr = 0x0000;
 630   5                                      first_get_addr_complete_flag = false;
 631   5                                      Rom_write(send_addr, 0);
 632   5                                      key_stop_tmr_flag = false;
 633   5                                      send_finish_flag = false;
 634   5                                      send_data = 0x00;
 635   5                                      key_state = send_data;
 636   5                                      reset_flag = true;
 637   5                                      longkey_flag = true;
 638   5                                      key_out_time = 0x20;
 639   5                              }
 640   4                              
 641   4                      }
 642   3                      break;
 643   3                      default:
 644   3                              break;
 645   3                      }
 646   2              }
 647   1              else if(key_ent_flag == true && key_out_time == 0x00)
 648   1              {
 649   2                      key_ent_flag = false;
 650   2                      longkey_flag = 0;
 651   2                      if(reset_flag == true)
 652   2                              reset_flag = false;
 653   2              }
 654   1      }
 655          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    863    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     12    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
