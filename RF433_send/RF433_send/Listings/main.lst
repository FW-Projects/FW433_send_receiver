C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5C51\C51\BIN\C51.EXE main.c ROM(COMPACT) OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "SN8F5702.H"
   2          #include "intrins.h"
   3          #include "delayms.h"
   4          #include "433send.h"
   5          #include "getkey.h"
   6          #include "ISP.h"
   7          #include "gpio.h"
   8          #include "tmr.h"
   9          
  10          #define uint8_t unsigned char
  11          #define uinttrue6_t unsigned int
  12          
  13          #define true 1
  14          #define false 0
  15          
  16          #define KEY_NULL 0x00
  17          #define KEY_CH1 0x01
  18          #define KEY_CH2 0x02
  19          #define KEY_CH3 0x03
  20          #define KEY_CH4 0x04
  21          
  22          #define KEY_TEMP_UP 0x05
  23          #define KEY_TEMP_DOWN 0x06
  24          
  25          #define KEY_AIR_UP 0x07
  26          #define KEY_AIR_DOWN 0x08
  27          #define KEY_CONFIRM 0x10
  28          #define KEY_Right_Code 0xff
  29          #define KEY_CLEAR_CODE 0x0f
  30          
  31          volatile uint8_t key_out_time = 0, key_state = 0,key_n = 0,start_init_outtime = 0;
  32          //volatile uint8_t  key_state = 0,start_init_outtime = 0;
  33          volatile uint8_t send_data = 0,first_get_addr_complete_flag = 0,send_counter = 0;
  34          volatile uint16_t send_addr = 0;
  35          volatile bit key_ent_flag = 0,longkey_flag = 0,tmr_stop_flag = 0,start_init_flag = 0;
  36          volatile bit start_init_end_flag = 0,key_stop_tmr_flag = 0,send_finish_flag = 0;
  37          
  38          void key_handle(void);
  39          void fisrt_get_addr_handle(void);
  40          void send_handle(void);
  41          void Start_init_handle(void);
  42          void Rom_write(uinttrue6_t in_data, uint8_t n);
  43          void Rom_read(void);
  44          uint16_t data_8bit_to_16bit(uint8_t n);
  45          void check_key(void);
  46          
  47          void T0Interrupt(void) interrupt ISRTimer0  
  48          {
  49   1              //TF0 clear
  50   1              TF0 = 0;
  51   1              TH0 = 0;
  52   1              TL0 = 0;
  53   1      }
  54          
C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 2   

  55          
  56          void T1Interrupt(void) interrupt ISRTimer1
  57          {
  58   1              if(key_n != 0x00)
  59   1              {
  60   2                      key_n --;
  61   2              }
  62   1              if(start_init_outtime != 0x00)
  63   1              {
  64   2                      start_init_outtime--;
  65   2              }
  66   1              if(key_out_time != 0x00)
  67   1              {
  68   2                      key_out_time--;
  69   2              }
  70   1              TH1 = (65536 - 10000) / 256;
  71   1              TL1 = (65536 - 10000) % 256;
  72   1              ET1 = 1; 
  73   1              TR1 = 1; 
  74   1              TF1 = 0;
  75   1      }
  76          
  77          void main(void)
  78          {
  79   1              /* system clock */
  80   1              CKCON = 0x70;
  81   1              CLKSEL = 0x05; // Fcpu = 32M
  82   1              CLKCMD = 0x69;
  83   1              WDTR = 0x5A;
  84   1      
  85   1              gpio_init();
  86   1              InitT0(); // 用于获取滚动码
  87   1              InitT1();
  88   1              Witty433_Init(set_433time_buf); // 433发送电平时间设置
  89   1              Rom_read();
  90   1              while (1)
  91   1              {
  92   2                      WDTR = 0x5A;
  93   2                      if (start_init_flag == 0)
  94   2                      {
  95   3                              if (first_get_addr_complete_flag == false)
  96   3                              {
  97   4                                      if(key_stop_tmr_flag == true)
  98   4                                      {
  99   5                                              // 出厂首次获取滚动码
 100   5                                              first_get_addr_complete_flag = true; // 设置首次获取地址码完成标志位
 101   5                                              key_stop_tmr_flag = false;                      
 102   5                                              start_init_flag = true;                         // 设置开始标志位
 103   5                                              fisrt_get_addr_handle();        
 104   5                                      }
 105   4                                      else
 106   4                                      {
 107   5      //                                      StartSend_433(0xffff, 0x00);
 108   5                                      }
 109   4                                                                                                                      // 获取地址码   
 110   4                              }
 111   3                              else 
 112   3                              {
 113   4                                      send_data = key_state;
 114   4                                      send_handle(); // 433发送处理
 115   4                              }
 116   3                      }
C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 3   

 117   2                      else 
 118   2                              Start_init_handle(); // 初始化处理
 119   2                      if (key_n  == 0)
 120   2                      {
 121   3                              key_handle(); // 按键识别
 122   3                              key_n  = 0x02;
 123   3                      }
 124   2              }
 125   1      }
 126          
 127          /*
 128           * 433发送处理
 129           * 起始码+地址码+控制码+结束码
 130           */
 131          void send_handle(void)
 132          {
 133   1      #if 1
 134   1              //发送5帧数据
 135   1              if(longkey_flag == true)  //长按一直发送
 136   1              {
 137   2                      StartSend_433(send_addr, send_data);
 138   2                      send_finish_flag = true;
 139   2              }
 140   1              else
 141   1              {
 142   2                      if(send_finish_flag == false)
 143   2                      {
 144   3                              StartSend_433(send_addr, send_data);
 145   3                              send_counter++;
 146   3                              if(send_counter > 5)
 147   3                              {
 148   4                                      key_state = KEY_NULL;
 149   4                                      send_finish_flag = true;
 150   4                                      send_counter = 0x00;
 151   4                              }
 152   3                      }
 153   2                      
 154   2              }
 155   1              
 156   1      
 157   1      
 158   1              
 159   1      #endif
 160   1      
 161   1      }
 162          
 163          /*
 164           *出厂首次获取地址码
 165           *通过定时器计数获取计数时间
 166           *计数时间作为地址码存储到flash中
 167           *计数时间范围0~65535
 168           *计数暂停标志为确认键长按
 169           */
 170          void fisrt_get_addr_handle(void)
 171          {                                 
 172   1              StopT0();                                                                                                                                 // 停止计数
 173   1              send_addr = TH0  << 8 | TL0;                              // 获取计数时间作为地址码
 174   1              u8_data[2] = first_get_addr_complete_flag; // 地址码高位
 175   1              Rom_write(send_addr, 0);                                          // 写入Flash
 176   1      }
 177          void Start_init_handle(void)
 178          {
C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 4   

 179   1              if (start_init_flag == true && start_init_end_flag == 0)
 180   1              {
 181   2      
 182   2                      start_init_end_flag = true; // 设置结束标志位
 183   2                      start_init_outtime = 0x0A;
 184   2                      send_finish_flag = false;
 185   2                      /* 读取ROM数据 */
 186   2                      send_addr = data_8bit_to_16bit(0); // ROM地址
 187   2      
 188   2                      first_get_addr_complete_flag = u8_data[2]; // 首次获取地址码完成标志位
 189   2                      if(first_get_addr_complete_flag > 1)
 190   2                              first_get_addr_complete_flag = 0;
 191   2                      if (first_get_addr_complete_flag == false)
 192   2                      {
 193   3                              // 出厂定时器开始计数
 194   3                              TH0 = 0x00; // 计数器清零
 195   3                              TL0 = 0x00;
 196   3                              StartT0(); // 启动计数
 197   3                      }
 198   2                      else
 199   2                              StopT0(); // 停止计数
 200   2              }
 201   1              else if (start_init_end_flag == true && start_init_outtime == 0x00)
 202   1              {
 203   2                      start_init_flag = false; // 复位标志位
 204   2                      start_init_end_flag = false;
 205   2              }
 206   1      }
 207          
 208          void Rom_write(uinttrue6_t in_data, uint8_t n)
 209          {
 210   1              /* true6bit数据暂存数组 */
 211   1              u8_data[n] = in_data >> 8; // 高位
 212   1              u8_data[n + 1] = in_data;  // 低位
 213   1              ISPpagewrite(u8_data);
 214   1      }
 215          
 216          uint16_t data_8bit_to_16bit(uint8_t n)
 217          {
 218   1              uinttrue6_t out_data;
 219   1              out_data = (u8_data[n] << 8) | u8_data[n + 1]; // true6bit数据
 220   1              return out_data;
 221   1      }
 222          void Rom_read(void)
 223          {
 224   1              ISPpageread2();
 225   1              start_init_flag = true;
 226   1              start_init_end_flag = 0;
 227   1              start_init_outtime = 0x00;
 228   1      }
 229          
 230          
 231          #if 1
 232          void key_handle(void)
 233          {
 234   1              uint8_t key_value;
 235   1              key_value = get_key();
 236   1              if (inkey_number == key_temp_up)
 237   1              {
 238   2                      switch (key_value)
 239   2                      {
 240   3                      case (keydown_ent):
C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 5   

 241   3                              break;
 242   3                      case (keyup_ent):
 243   3                      {
 244   4                              if(longkey_flag == 0)
 245   4                              {
 246   5                                      key_ent_flag = true;
 247   5                                      key_state = KEY_TEMP_UP;
 248   5                                      send_finish_flag = false;
 249   5                              }
 250   4                              inkey_number = key_null;
 251   4                              longkey_flag = false;
 252   4                      }
 253   3                      break;
 254   3                      case (key_long):
 255   3                              break;
 256   3                      case (key_continue):
 257   3                      {
 258   4                              if(longkey_flag == 0)
 259   4                              {
 260   5                                      key_ent_flag = true;
 261   5                                      key_state = KEY_TEMP_UP;
 262   5                                      send_finish_flag = false;
 263   5                                      longkey_flag = true;
 264   5                              }
 265   4                      }
 266   3                      break;
 267   3                      default:
 268   3                              break;
 269   3                      }
 270   2              }
 271   1              else if (inkey_number == key_temp_down)
 272   1              {
 273   2                      switch (key_value)
 274   2                      {
 275   3                      case (keydown_ent):
 276   3                              break;
 277   3                      case (keyup_ent):
 278   3                      {
 279   4                              if(longkey_flag == 0)
 280   4                              {
 281   5                                      key_ent_flag = true;
 282   5                                      key_state = KEY_TEMP_DOWN;
 283   5                                      send_finish_flag = false;
 284   5                              }
 285   4                              longkey_flag = false;
 286   4                              inkey_number = key_null;
 287   4                      }
 288   3                      break;
 289   3                      case (key_long):
 290   3                              break;
 291   3                      case (key_continue):
 292   3                      {
 293   4                              if(longkey_flag == 0)
 294   4                              {
 295   5                                      key_ent_flag = true;
 296   5                                      key_state = KEY_TEMP_DOWN;
 297   5                                      send_finish_flag = false;
 298   5                                      longkey_flag = true;
 299   5                              }
 300   4                      }
 301   3                      break;
 302   3                      default:
C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 6   

 303   3                              break;
 304   3                      }
 305   2              }
 306   1              else if (inkey_number == key_air_up)
 307   1              {
 308   2                      switch (key_value)
 309   2                      {
 310   3                      case (keydown_ent):
 311   3                              break;
 312   3                      case (keyup_ent):
 313   3                      {
 314   4                              if(longkey_flag == 0)
 315   4                              {
 316   5                                      key_ent_flag = true;
 317   5                                      key_state = KEY_AIR_UP;
 318   5                                      send_finish_flag = false;
 319   5                              }
 320   4                              longkey_flag = false;
 321   4                              inkey_number = key_null;
 322   4                      }
 323   3                      break;
 324   3                      case (key_long):
 325   3                              break;
 326   3                      case (key_continue):
 327   3                      {
 328   4                              if(longkey_flag == 0)
 329   4                              {
 330   5                                      key_ent_flag = true;
 331   5                                      key_state = KEY_AIR_UP;
 332   5                                      send_finish_flag = false;
 333   5                                      longkey_flag = true;
 334   5                              }
 335   4                      }
 336   3                      break;
 337   3                      default:
 338   3                              break;
 339   3                      }
 340   2              }
 341   1              else if (inkey_number == key_air_down)
 342   1              {
 343   2                      switch (key_value)
 344   2                      {
 345   3                      case (keydown_ent):
 346   3                              break;
 347   3                      case (keyup_ent):
 348   3                      {
 349   4                              if(longkey_flag == 0)
 350   4                              {
 351   5                              key_ent_flag = true;
 352   5                              key_state = KEY_AIR_DOWN;
 353   5                              send_finish_flag = false;
 354   5                              }
 355   4                              longkey_flag = false;
 356   4                              inkey_number = key_null;
 357   4                      }
 358   3                      break;
 359   3                      case (key_long):
 360   3                              break;
 361   3                      case (key_continue):
 362   3                      {
 363   4                              if(longkey_flag == 0)
 364   4                              {
C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 7   

 365   5                                      key_ent_flag = true;
 366   5                                      key_state = KEY_AIR_DOWN;
 367   5                                      send_finish_flag = false;
 368   5                                      longkey_flag = true;
 369   5                              }
 370   4                      }
 371   3                      break;
 372   3                      default:
 373   3                              break;
 374   3                      }
 375   2              }
 376   1              else if (inkey_number == key_ch1)
 377   1              {
 378   2                      switch (key_value)
 379   2                      {
 380   3                      case (keydown_ent):
 381   3                              break;
 382   3                      case (keyup_ent):
 383   3                      {
 384   4                              key_ent_flag = true;
 385   4                              key_state = KEY_CH1;
 386   4                              send_finish_flag = false;
 387   4                              inkey_number = key_null;
 388   4                      }
 389   3                      break;
 390   3                      case (key_long):
 391   3                              break;
 392   3                      case (key_continue):
 393   3                      {
 394   4                              key_ent_flag = true;
 395   4                              longkey_flag = true;
 396   4                      }
 397   3                      break;
 398   3                      default:
 399   3                              break;
 400   3                      }
 401   2              }
 402   1              else if (inkey_number == key_ch2)
 403   1              {
 404   2                      switch (key_value)
 405   2                      {
 406   3                      case (keydown_ent):
 407   3                              break;
 408   3                      case (keyup_ent):
 409   3                      {
 410   4                              key_ent_flag = true;
 411   4                              key_state = KEY_CH2;
 412   4                              send_finish_flag = false;
 413   4                              inkey_number = key_null;
 414   4                      }
 415   3                      break;
 416   3                      case (key_long):
 417   3                              break;
 418   3                      case (key_continue):
 419   3                      {
 420   4                              key_ent_flag = true;
 421   4                              longkey_flag = true;
 422   4                      }
 423   3                      break;
 424   3                      default:
 425   3                              break;
 426   3                      }
C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 8   

 427   2              }
 428   1              else if (inkey_number == key_ch3)
 429   1              {
 430   2                      switch (key_value)
 431   2                      {
 432   3                      case (keydown_ent):
 433   3                              break;
 434   3                      case (keyup_ent):
 435   3                      {
 436   4                              key_ent_flag = true;
 437   4                              key_state = KEY_CH3;
 438   4                              send_finish_flag = false;
 439   4                              inkey_number = key_null;
 440   4                      }
 441   3                      break;
 442   3                      case (key_long):
 443   3                              break;
 444   3                      case (key_continue):
 445   3                      {
 446   4                              key_ent_flag = true;
 447   4                              longkey_flag = true;
 448   4                      }
 449   3                      break;
 450   3                      default:
 451   3                              break;
 452   3                      }
 453   2              }
 454   1              else if (inkey_number == key_ch4)
 455   1              {
 456   2                      switch (key_value)
 457   2                      {
 458   3                      case (keydown_ent):
 459   3                              break;
 460   3                      case (keyup_ent):
 461   3                      {
 462   4                              key_ent_flag = true;
 463   4                              key_state = KEY_CH4;
 464   4                              send_finish_flag = false;
 465   4                              inkey_number = key_null;
 466   4                      }
 467   3                      break;
 468   3                      case (key_long):
 469   3                              break;
 470   3                      case (key_continue):
 471   3                      {
 472   4                              key_ent_flag = true;
 473   4                              longkey_flag = true;
 474   4                      }
 475   3                      break;
 476   3                      default:
 477   3                              break;
 478   3                      }
 479   2              }
 480   1              else if (inkey_number == key_confirm)
 481   1              {
 482   2                      /* 确认按键  &  滚动码
 483   2                       * 滚动码 ： 长按确认键 确定机器滚动码
 484   2                       */
 485   2                      switch (key_value)
 486   2                      {
 487   3                      case (keyup_ent):
 488   3                      {
C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 9   

 489   4                              if(longkey_flag == 0)
 490   4                              {
 491   5                              key_ent_flag = true;
 492   5                              key_state = KEY_CONFIRM;
 493   5                              send_finish_flag = false;
 494   5                              }
 495   4                              longkey_flag = false;
 496   4                              inkey_number = key_null;
 497   4                      }
 498   3                      break;
 499   3                      case (key_continue):
 500   3                      {
 501   4                              if(longkey_flag == 0)
 502   4                              {
 503   5                                      key_ent_flag = true;
 504   5                                      if(first_get_addr_complete_flag == false)
 505   5                                              key_stop_tmr_flag = true; // 停止计数
 506   5                                      else
 507   5                                              key_state = KEY_Right_Code;
 508   5                                      send_finish_flag = false;
 509   5                                      longkey_flag = true;
 510   5                              }
 511   4                              
 512   4                      }
 513   3                      break;
 514   3                      default:
 515   3                              break;
 516   3                      }
 517   2              }
 518   1              else if (inkey_number == key_clear)
 519   1              {
 520   2                      /* 清除对码  
 521   2                       */
 522   2                      switch (key_value)
 523   2                      {
 524   3                      case (keyup_ent):
 525   3                      {
 526   4                              inkey_number = key_null;
 527   4                      }
 528   3                      break;
 529   3                      case (key_continue):
 530   3                      {
 531   4                              if(longkey_flag == 0)
 532   4                              {
 533   5                                      key_ent_flag = true;
 534   5                                      key_state = KEY_CLEAR_CODE;
 535   5                                      send_finish_flag = false;
 536   5                                      longkey_flag = true;
 537   5                              }
 538   4                              
 539   4                      }
 540   3                      break;
 541   3                      default:
 542   3                              break;
 543   3                      }
 544   2                      
 545   2              }
 546   1      }
 547          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.60.7.0   MAIN                                                              08/18/2025 16:17:57 PAGE 10  

   CODE SIZE        =    894    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      7    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
