C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\keil5C51\C51\BIN\C51.EXE main.c COMPACT ROM(COMPACT) OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND
                    - PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "SN8F5703.H"
   2          #include "intrins.h"
   3          #include "delayms.h"
   4          #include "433send.h"
   5          #include "getkey.h"
   6          #include "ISP.h"
   7          #include "gpio.h"
   8          #include "tmr.h"
   9          
  10          #define uint8_t unsigned char
  11          #define uinttrue6_t unsigned int
  12          
  13          #define true 1
  14          #define false 0
  15          
  16          #define KEY_NULL 0x00
  17          #define KEY_CH1 0x01
  18          #define KEY_CH2 0x02
  19          #define KEY_CH3 0x03
  20          #define KEY_CH4 0x04
  21          
  22          #define KEY_TEMP_UP 0x05
  23          #define KEY_TEMP_DOWN 0x06
  24          
  25          #define KEY_AIR_UP 0x07
  26          #define KEY_AIR_DOWN 0x08
  27          #define KEY_SWITCH_HANDLE 0x09
  28          
  29          #define KEY_Right_Code 0xff
  30          #define KEY_CLEAR_CODE 0x0f
  31          
  32          sbit SEND_LED = P2 ^ 4;
  33          sbit Battery_LED = P2 ^ 3;
  34          sbit charge_flag = P2 ^ 1; 
  35          sbit Full_Battery = P2 ^ 2;
  36          
  37          volatile uint8_t key_out_time = 0, key_state = 0,key_n = 0,start_init_outtime = 0,reset_led_time = 0,led_t
             -ime1 = 0x00,led_times1 = 0x00;
  38          volatile uint8_t send_data = 0,first_get_addr_complete_flag = 0,send_counter = 0,led_times = 0,while_n = 0
             -x00;
  39          volatile uint16_t send_addr = 0;
  40          volatile bit key_ent_flag = 0,longkey_flag = 0,tmr_stop_flag = 0,start_init_flag = 0,reset_flag = 0;
  41          volatile bit start_init_end_flag = 0,key_stop_tmr_flag = 0,send_finish_flag = 0,open_led_flag = 0,get_addr
             -_led_flag = 0;
  42          
  43          void key_handle(void);
  44          void fisrt_get_addr_handle(void);
  45          void send_handle(void);
  46          void Start_init_handle(void);
  47          void Rom_write(uinttrue6_t in_data, uint8_t n);
  48          void Rom_read(void);
  49          uint16_t data_8bit_to_16bit(uint8_t n);
  50          void check_key(void);
  51          
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 2   

  52          void T0Interrupt(void) interrupt ISRTimer0  
  53          {
  54   1              //TF0 clear
  55   1              TF0 = 0;
  56   1              TH0 = 0;
  57   1              TL0 = 0;
  58   1      }
  59          
  60          
  61          void T1Interrupt(void) interrupt ISRTimer1
  62          {
  63   1              if(key_n != 0x00)
  64   1              {
  65   2                      key_n --;
  66   2              }
  67   1              if(start_init_outtime != 0x00)
  68   1              {
  69   2                      start_init_outtime--;
  70   2              }
  71   1              if(key_out_time != 0x00)
  72   1              {
  73   2                      key_out_time--;
  74   2              }
  75   1              if(get_addr_led_flag == true)  //获取滚动码
  76   1              {
  77   2                      if(led_time1 != 0x00)
  78   2                              led_time1--;
  79   2                      else
  80   2                      {
  81   3                              led_time1 = 0x01;
  82   3                              SEND_LED = ~SEND_LED;
  83   3                              Battery_LED = ~Battery_LED;
  84   3                              led_times1++;
  85   3                      }
  86   2                      if(led_times1 > 10)
  87   2                      {
  88   3                              led_times1 = 0x00;
  89   3                              get_addr_led_flag = false;
  90   3                              SEND_LED = true;
  91   3                              Battery_LED = true;
  92   3                      }
  93   2              }
  94   1              else
  95   1              {
  96   2                      if(reset_flag == true || open_led_flag == true) //恢复出厂设置 / 433发送 / 对码
  97   2                      {
  98   3                              if(reset_led_time != 0x00)
  99   3                                      reset_led_time--;
 100   3                              else
 101   3                              {
 102   4                                      reset_led_time = 0x01;
 103   4                                      SEND_LED = ~SEND_LED;
 104   4                                      led_times++;
 105   4                              }
 106   3                              if(reset_flag == true && led_times > 16)
 107   3                              {
 108   4                                      led_times = 0x00;
 109   4                                      SEND_LED = 1;
 110   4                                      reset_flag = false;
 111   4                              }
 112   3                              if(open_led_flag == true && led_times > 6)
 113   3                              {
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 3   

 114   4                                      led_times = 0x00;
 115   4                                      SEND_LED = 1;
 116   4                                      open_led_flag = false;
 117   4                              }
 118   3                      }
 119   2              }
 120   1              
 121   1              TH1 = (65536 - 50000) / 256;
 122   1              TL1 = (65536 - 50000) % 256;
 123   1              ET1 = 1; 
 124   1              TR1 = 1; 
 125   1              TF1 = 0;
 126   1      }
 127          
 128          void main(void)
 129          {
 130   1              /* system clock */
 131   1              CKCON = 0x70;
 132   1              CLKSEL = 0x05; // Fcpu = 32M
 133   1              CLKCMD = 0x69;
 134   1              WDTR = 0x5A;
 135   1      
 136   1              gpio_init();
 137   1              InitT0(); // 用于获取滚动码
 138   1              InitT1();
 139   1              Witty433_Init(set_433time_buf); // 433发送电平时间设置
 140   1              Rom_read();
 141   1              while (1)
 142   1              {
 143   2                      WDTR = 0x5A;
 144   2                      if (start_init_flag == 0)
 145   2                      {
 146   3                              if (first_get_addr_complete_flag == false)
 147   3                              {
 148   4                                      if(key_stop_tmr_flag == true)
 149   4                                      {
 150   5                                              // 出厂首次获取滚动码
 151   5                                              first_get_addr_complete_flag = true; // 设置首次获取地址码完成标志位
 152   5                                              key_stop_tmr_flag = false;                      
 153   5      //                                      start_init_flag = true;                         // 设置开始标志位
 154   5                                              get_addr_led_flag = true;
 155   5                                              fisrt_get_addr_handle();        
 156   5                                      }
 157   4                                      else
 158   4                                      {
 159   5      //                                      StartSend_433(0xffff, 0x00);
 160   5                                      }
 161   4                                                                                                                      // 获取地址码   
 162   4                              }
 163   3                              else 
 164   3                              {
 165   4                                      send_data = key_state;
 166   4                                      send_handle(); // 433发送处理
 167   4                              }
 168   3                      }
 169   2                      else 
 170   2                              Start_init_handle(); // 初始化处理
 171   2                      switch(while_n)
 172   2                      {
 173   3                              case 1: 
 174   3                                      if(charge_flag == 0)
 175   3                                      {
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 4   

 176   4                                              if(Full_Battery == 0)
 177   4                                                      Battery_LED = true;
 178   4                                              else
 179   4                                                      Battery_LED = false;
 180   4                                      }
 181   3                                      else 
 182   3                                              Battery_LED = true;
 183   3                                      break;
 184   3                              case 2:
 185   3                                      if (key_n  == 0)
 186   3                                      {
 187   4                                              key_handle(); // 按键识别
 188   4                                              key_n  = 0;
 189   4                                      }
 190   3                                      break;
 191   3                              default:
 192   3                                      while_n = 0x00;
 193   3                                      break;
 194   3                              
 195   3                      }
 196   2                      while_n++;
 197   2                      
 198   2              }
 199   1      }
 200          
 201          /*
 202           * 433发送处理
 203           * 起始码+地址码+控制码+结束码
 204           */
 205          void send_handle(void)
 206          {
 207   1      #if 1
 208   1              //发送5帧数据
 209   1              if(longkey_flag == true)  //长按一直发送
 210   1              {
 211   2                      StartSend_433(send_addr, send_data);
 212   2                      send_finish_flag = true;
 213   2                      open_led_flag = true;
 214   2              }
 215   1              else
 216   1              {
 217   2                      if(send_finish_flag == false)
 218   2                      {
 219   3                              StartSend_433(send_addr, send_data);
 220   3                              send_finish_flag = true;
 221   3                              open_led_flag = true;
 222   3      //                      send_counter++;
 223   3      //                      if(send_counter > 5)
 224   3      //                      {
 225   3      //                              key_state = KEY_NULL;
 226   3      //                              send_finish_flag = true;
 227   3      //                              send_counter = 0x00;
 228   3      //                              open_led_flag = true;
 229   3      //                      }
 230   3                      }
 231   2                      
 232   2              }
 233   1              
 234   1      
 235   1      
 236   1              
 237   1      #endif
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 5   

 238   1      
 239   1      }
 240          
 241          /*
 242           *出厂首次获取地址码
 243           *通过定时器计数获取计数时间
 244           *计数时间作为地址码存储到flash中
 245           *计数时间范围0~65535
 246           *计数暂停标志为确认键长按
 247           */
 248          void fisrt_get_addr_handle(void)
 249          {                                 
 250   1              StopT0();                                                                                                                                 // 停止计数
 251   1              send_addr = TH0  << 8 | TL0;                              // 获取计数时间作为地址码
 252   1              u8_data[2] = first_get_addr_complete_flag; // 地址码高位
 253   1              Rom_write(send_addr, 0);                                          // 写入Flash
 254   1      }
 255          void Start_init_handle(void)
 256          {
 257   1              if (start_init_flag == true && start_init_end_flag == 0)
 258   1              {
 259   2      
 260   2                      start_init_end_flag = true; // 设置结束标志位
 261   2                      start_init_outtime = 0x0A;
 262   2                      send_finish_flag = false;
 263   2                      /* 读取ROM数据 */
 264   2                      send_addr = data_8bit_to_16bit(0); // ROM地址
 265   2      
 266   2                      first_get_addr_complete_flag = u8_data[2]; // 首次获取地址码完成标志位
 267   2                      if(first_get_addr_complete_flag != 0)
 268   2                              first_get_addr_complete_flag = 0;
 269   2                      if (first_get_addr_complete_flag == false)
 270   2                      {
 271   3                              // 出厂定时器开始计数
 272   3                              TH0 = 0x00; // 计数器清零
 273   3                              TL0 = 0x00;
 274   3                              StartT0(); // 启动计数
 275   3                      }
 276   2                      else
 277   2                              StopT0(); // 停止计数
 278   2              }
 279   1              else if (start_init_end_flag == true && start_init_outtime == 0x00)
 280   1              {
 281   2                      start_init_flag = false; // 复位标志位
 282   2                      start_init_end_flag = false;
 283   2              }
 284   1      }
 285          
 286          void Rom_write(uinttrue6_t in_data, uint8_t n)
 287          {
 288   1              /* true6bit数据暂存数组 */
 289   1              u8_data[n] = in_data >> 8; // 高位
 290   1              u8_data[n + 1] = in_data;  // 低位
 291   1              ISPpagewrite(u8_data);
 292   1      }
 293          
 294          uint16_t data_8bit_to_16bit(uint8_t n)
 295          {
 296   1              uinttrue6_t out_data;
 297   1              out_data = (u8_data[n] << 8) | u8_data[n + 1]; // true6bit数据
 298   1              return out_data;
 299   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 6   

 300          void Rom_read(void)
 301          {
 302   1              ISPpageread2();
 303   1              start_init_flag = true;
 304   1              start_init_end_flag = 0;
 305   1              start_init_outtime = 0x00;
 306   1      }
 307          
 308          
 309          #if 1
 310          void key_handle(void)
 311          {
 312   1              uint8_t key_value;
 313   1              key_value = get_key();
 314   1              if (inkey_number == key_temp_up)
 315   1              {
 316   2                      switch (key_value)
 317   2                      {
 318   3                      case (keydown_ent):
 319   3                              break;
 320   3                      case (keyup_ent):
 321   3                      {
 322   4                              key_ent_flag = true;
 323   4                              key_state = KEY_TEMP_UP;
 324   4                              send_finish_flag = false;
 325   4                              inkey_number = key_null;
 326   4                              key_out_time = 0x05;
 327   4                      }
 328   3                      break;
 329   3                      case (key_long):
 330   3                              break;
 331   3                      case (key_continue):break;
 332   3                      default:
 333   3                              break;
 334   3                      }
 335   2              }
 336   1              else if (inkey_number == key_temp_down)
 337   1              {
 338   2                      switch (key_value)
 339   2                      {
 340   3                      case (keydown_ent):
 341   3                              break;
 342   3                      case (keyup_ent):
 343   3                      {
 344   4                              key_ent_flag = true;
 345   4                              key_state = KEY_TEMP_DOWN;
 346   4                              send_finish_flag = false;
 347   4                              inkey_number = key_null;
 348   4                              key_out_time = 0x05;
 349   4                      }
 350   3                      break;
 351   3                      case (key_long):
 352   3                              break;
 353   3                      case (key_continue):
 354   3                      break;
 355   3                      default:
 356   3                              break;
 357   3                      }
 358   2              }
 359   1              else if (inkey_number == key_air_up)
 360   1              {
 361   2                      switch (key_value)
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 7   

 362   2                      {
 363   3                      case (keydown_ent):
 364   3                              break;
 365   3                      case (keyup_ent):
 366   3                      {
 367   4                              key_ent_flag = true;
 368   4                              key_state = KEY_AIR_UP;
 369   4                              send_finish_flag = false;
 370   4                              inkey_number = key_null;
 371   4                              key_out_time = 0x05;
 372   4                      }
 373   3                      break;
 374   3                      case (key_long):
 375   3                              break;
 376   3                      case (key_continue):
 377   3                      break;
 378   3                      default:
 379   3                              break;
 380   3                      }
 381   2              }
 382   1              else if (inkey_number == key_air_down)
 383   1              {
 384   2                      switch (key_value)
 385   2                      {
 386   3                      case (keydown_ent):
 387   3                              break;
 388   3                      case (keyup_ent):
 389   3                      {
 390   4                              key_ent_flag = true;
 391   4                              key_state = KEY_AIR_DOWN;
 392   4                              send_finish_flag = false;
 393   4                              inkey_number = key_null;
 394   4                              key_out_time = 0x05;
 395   4                      }
 396   3                      break;
 397   3                      case (key_long):
 398   3                              break;
 399   3                      case (key_continue):
 400   3                      break;
 401   3                      default:
 402   3                              break;
 403   3                      }
 404   2              }
 405   1              else if (inkey_number == key_ch1)
 406   1              {
 407   2                      switch (key_value)
 408   2                      {
 409   3                      case (keydown_ent):
 410   3                              break;
 411   3                      case (keyup_ent):
 412   3                      {
 413   4                              key_ent_flag = true;
 414   4                              key_state = KEY_CH1;
 415   4                              send_finish_flag = false;
 416   4                              inkey_number = key_null;
 417   4                              key_out_time = 0x05;
 418   4                      }
 419   3                      break;
 420   3                      case (key_long):
 421   3                              break;
 422   3                      case (key_continue):
 423   3                      break;
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 8   

 424   3                      default:
 425   3                              break;
 426   3                      }
 427   2              }
 428   1              else if (inkey_number == key_ch2)
 429   1              {
 430   2                      switch (key_value)
 431   2                      {
 432   3                      case (keydown_ent):
 433   3                              break;
 434   3                      case (keyup_ent):
 435   3                      {
 436   4                              key_ent_flag = true;
 437   4                              key_state = KEY_CH2;
 438   4                              send_finish_flag = false;
 439   4                              inkey_number = key_null;
 440   4                              key_out_time = 0x05;
 441   4                      }
 442   3                      break;
 443   3                      case (key_long):
 444   3                              break;
 445   3                      case (key_continue):
 446   3                      break;
 447   3                      default:
 448   3                              break;
 449   3                      }
 450   2              }
 451   1              else if (inkey_number == key_ch3)
 452   1              {
 453   2                      switch (key_value)
 454   2                      {
 455   3                      case (keydown_ent):
 456   3                              break;
 457   3                      case (keyup_ent):
 458   3                      {
 459   4                              key_ent_flag = true;
 460   4                              key_state = KEY_CH3;
 461   4                              send_finish_flag = false;
 462   4                              inkey_number = key_null;
 463   4                              key_out_time = 0x05;
 464   4                      }
 465   3                      break;
 466   3                      case (key_long):
 467   3                              break;
 468   3                      case (key_continue):
 469   3                      break;
 470   3                      default:
 471   3                              break;
 472   3                      }
 473   2              }
 474   1              else if (inkey_number == key_ch4)
 475   1              {
 476   2                      switch (key_value)
 477   2                      {
 478   3                      case (keydown_ent):
 479   3                              break;
 480   3                      case (keyup_ent):
 481   3                      {
 482   4                              key_ent_flag = true;
 483   4                              key_state = KEY_CH4;
 484   4                              send_finish_flag = false;
 485   4                              inkey_number = key_null;
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 9   

 486   4                              key_out_time = 0x05;
 487   4                      }
 488   3                      break;
 489   3                      case (key_long):
 490   3                              break;
 491   3                      case (key_continue):
 492   3                      break;
 493   3                      default:
 494   3                              break;
 495   3                      }
 496   2              }
 497   1              else if (inkey_number == KEY_Switch_handle)
 498   1              {
 499   2                      /* 确认按键  &  滚动码
 500   2                       * 滚动码 ： 长按确认键 确定机器滚动码
 501   2                       */
 502   2                      switch (key_value)
 503   2                      {
 504   3                      case (keyup_ent):
 505   3                      {
 506   4                              if(longkey_flag == 0)
 507   4                              {
 508   5                                      //切换手柄
 509   5                                      key_ent_flag = true;
 510   5                                      key_state = KEY_SWITCH_HANDLE;
 511   5                                      send_finish_flag = false;
 512   5                                      key_out_time = 0x05;
 513   5                              }
 514   4                              longkey_flag = false;
 515   4                              inkey_number = key_null;
 516   4                      }
 517   3                      break;
 518   3                      case (key_continue):
 519   3                      {
 520   4                              if(longkey_flag == 0)
 521   4                              {
 522   5                                      key_ent_flag = true;
 523   5                                      if(first_get_addr_complete_flag == false)
 524   5                                              key_stop_tmr_flag = true; // 停止计数
 525   5                                      else
 526   5                                              key_state = KEY_Right_Code;
 527   5                                      send_finish_flag = false;
 528   5                                      longkey_flag = true;
 529   5                                      key_out_time = 0x05;
 530   5                              }
 531   4                              
 532   4                      }
 533   3                      break;
 534   3                      default:
 535   3                              break;
 536   3                      }
 537   2              }
 538   1              else if (inkey_number == key_clear)
 539   1              {
 540   2                      /* 清除对码  
 541   2                       */
 542   2                      switch (key_value)
 543   2                      {
 544   3                      case (keyup_ent):
 545   3                      {
 546   4                              inkey_number = key_null;
 547   4                              longkey_flag = false;
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 10  

 548   4                      }
 549   3                      break;
 550   3                      case (key_continue):
 551   3                      {
 552   4                              if(longkey_flag == 0)
 553   4                              {
 554   5                                      key_ent_flag = true;
 555   5                                      key_state = KEY_CLEAR_CODE;
 556   5                                      send_finish_flag = false;
 557   5                                      longkey_flag = true;
 558   5                                      key_out_time = 0x05;
 559   5                              }
 560   4                              
 561   4                      }
 562   3                      break;
 563   3                      default:
 564   3                              break;
 565   3                      }
 566   2              }
 567   1              else if( inkey_number == key_reset)
 568   1              {
 569   2                      /* 恢复出厂设置 需要重新获取滚动码  
 570   2                       */
 571   2                      switch (key_value)
 572   2                      {
 573   3                      case (keyup_ent):
 574   3                      {
 575   4                              inkey_number = key_null;
 576   4                              longkey_flag = false;
 577   4                      }
 578   3                      break;
 579   3                      case (key_continue):
 580   3                      {
 581   4                              if(longkey_flag == 0)
 582   4                              {
 583   5                                      key_ent_flag = true;
 584   5                                      send_addr = 0x0000;
 585   5                                      first_get_addr_complete_flag = false;
 586   5                                      Rom_write(send_addr, 0);
 587   5                                      key_stop_tmr_flag = false;
 588   5                                      send_finish_flag = false;
 589   5                                      send_data = 0x00;
 590   5                                      key_state = send_data;
 591   5                                      reset_flag = true;
 592   5                                      longkey_flag = true;
 593   5                                      key_out_time = 0x20;
 594   5                              }
 595   4                              
 596   4                      }
 597   3                      break;
 598   3                      default:
 599   3                              break;
 600   3                      }
 601   2              }
 602   1              else if(key_ent_flag == true && key_out_time == 0x00)
 603   1              {
 604   2                      key_ent_flag = false;
 605   2                      longkey_flag = 0;
 606   2                      if(reset_flag == true)
 607   2                              reset_flag = false;
 608   2              }
 609   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              09/15/2025 15:22:47 PAGE 11  

 610          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1270    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     21    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     10    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
